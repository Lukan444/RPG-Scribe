/**
 * Entity Vector Integration Service
 * 
 * Integrates the VertexAI Index Service with all 10 core RPG Scribe entity types,
 * providing automatic vector synchronization and semantic search capabilities.
 */

import { VertexAIIndexService, EntityVectorData } from './VertexAIIndexService';
import { FirestoreService } from '../firestore.service';
import { EntityType } from '../../models/EntityType';
import { Character } from '../../models/Character';
import { Location } from '../../models/Location';
import { Item } from '../../models/Item';
import { Event } from '../../models/Event';
import { getConfig } from './config';

/**
 * Entity content extraction interface
 */
interface EntityContent {
  title: string;
  description: string;
  tags: string[];
  metadata: Record<string, any>;
}

/**
 * Synchronization result for entity operations
 */
interface EntitySyncResult {
  entityId: string;
  entityType: EntityType;
  success: boolean;
  embeddingId?: string;
  error?: string;
  processingTime: number;
}

/**
 * Batch synchronization options
 */
interface BatchSyncOptions {
  batchSize?: number;
  maxConcurrency?: number;
  skipExisting?: boolean;
  forceUpdate?: boolean;
  worldId?: string;
  campaignId?: string;
}

/**
 * Entity Vector Integration Service
 */
export class EntityVectorIntegrationService {
  private indexService: VertexAIIndexService;
  private firestoreServices: Map<EntityType, FirestoreService<any>> = new Map();
  private initialized = false;

  constructor() {
    const config = getConfig('development');
    this.indexService = new VertexAIIndexService(config);
    this.initializeFirestoreServices();
  }

  /**
   * Initialize the service
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      console.log('Initializing Entity Vector Integration Service...');
      
      await this.indexService.initialize();
      
      // Create entity-specific indexes
      await this.createEntityIndexes();
      
      this.initialized = true;
      console.log('Entity Vector Integration Service initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Entity Vector Integration Service:', error);
      throw error;
    }
  }

  /**
   * Synchronize a single entity with vector storage
   */
  async syncEntity(
    entityId: string,
    entityType: EntityType,
    worldId?: string,
    campaignId?: string
  ): Promise<EntitySyncResult> {
    const startTime = Date.now();
    
    try {
      if (!this.initialized) {
        await this.initialize();
      }

      // Get entity data
      const firestoreService = this.firestoreServices.get(entityType);
      if (!firestoreService) {
        throw new Error(`No Firestore service configured for entity type: ${entityType}`);
      }

      const entity = await firestoreService.getById(entityId);
      if (!entity) {
        throw new Error(`Entity ${entityId} not found`);
      }

      // Extract content for embedding
      const content = this.extractEntityContent(entity, entityType);
      
      // Create vector data
      const vectorData: EntityVectorData = {
        entityId,
        entityType,
        worldId: worldId || entity.worldId,
        campaignId: campaignId || entity.campaignId,
        embedding: [], // Will be generated by the index service
        metadata: {
          name: content.title,
          description: content.description,
          tags: content.tags,
          lastUpdated: new Date(),
          schemaVersion: 1
        }
      };

      // Generate embedding and store
      const result = await this.indexService.addEntityVectors([vectorData]);
      
      const processingTime = Date.now() - startTime;
      
      return {
        entityId,
        entityType,
        success: result.success,
        embeddingId: result.success ? entityId : undefined,
        error: result.success ? undefined : result.errors[0]?.error,
        processingTime
      };
    } catch (error) {
      const processingTime = Date.now() - startTime;
      
      return {
        entityId,
        entityType,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        processingTime
      };
    }
  }

  /**
   * Synchronize multiple entities in batch
   */
  async syncEntitiesBatch(
    entities: Array<{ id: string; type: EntityType; worldId?: string; campaignId?: string }>,
    options: BatchSyncOptions = {}
  ): Promise<EntitySyncResult[]> {
    const {
      batchSize = 50,
      maxConcurrency = 5,
      skipExisting = false,
      forceUpdate = false
    } = options;

    console.log(`Starting batch sync for ${entities.length} entities`);
    
    const results: EntitySyncResult[] = [];
    const batches = this.chunkArray(entities, batchSize);
    
    for (const batch of batches) {
      const batchPromises = batch.map(entity => 
        this.syncEntity(entity.id, entity.type, entity.worldId, entity.campaignId)
      );
      
      // Process batch with concurrency limit
      const batchResults = await this.processConcurrently(batchPromises, maxConcurrency);
      results.push(...batchResults);
    }

    const successCount = results.filter(r => r.success).length;
    console.log(`Batch sync completed: ${successCount}/${entities.length} successful`);
    
    return results;
  }

  /**
   * Search for similar entities across all types
   */
  async searchSimilarEntities(
    query: string,
    options: {
      entityTypes?: EntityType[];
      worldId?: string;
      campaignId?: string;
      limit?: number;
      minScore?: number;
    } = {}
  ) {
    if (!this.initialized) {
      await this.initialize();
    }

    const {
      entityTypes = Object.values(EntityType),
      worldId,
      campaignId,
      limit = 10,
      minScore = 0.7
    } = options;

    return await this.indexService.semanticSearch(query, {
      entityTypes,
      worldId,
      campaignId,
      limit,
      minScore,
      includeMetadata: true
    });
  }

  /**
   * Remove entity from vector storage
   */
  async removeEntity(
    entityId: string,
    entityType: EntityType,
    worldId?: string,
    campaignId?: string
  ): Promise<boolean> {
    try {
      if (!this.initialized) {
        await this.initialize();
      }

      const result = await this.indexService.removeEntityVectors(
        [entityId],
        entityType,
        worldId,
        campaignId
      );

      return result.success;
    } catch (error) {
      console.error(`Failed to remove entity ${entityId}:`, error);
      return false;
    }
  }

  /**
   * Get synchronization status for entities
   */
  async getSyncStatus(entityIds: string[]): Promise<Map<string, boolean>> {
    // This would check if entities have been synchronized
    // For now, return a simple implementation
    const status = new Map<string, boolean>();
    
    for (const entityId of entityIds) {
      // In a real implementation, this would check vector storage
      status.set(entityId, true);
    }
    
    return status;
  }

  /**
   * Initialize Firestore services for all entity types
   */
  private initializeFirestoreServices(): void {
    const entityCollections = {
      [EntityType.CHARACTER]: 'characters',
      [EntityType.LOCATION]: 'locations',
      [EntityType.ITEM]: 'items',
      [EntityType.EVENT]: 'events',
      [EntityType.SESSION]: 'sessions',
      [EntityType.FACTION]: 'factions',
      [EntityType.STORY_ARC]: 'storyArcs',
      [EntityType.NOTE]: 'notes',
      [EntityType.CAMPAIGN]: 'campaigns',
      [EntityType.RPG_WORLD]: 'rpgWorlds'
    };

    for (const [entityType, collection] of Object.entries(entityCollections)) {
      this.firestoreServices.set(
        entityType as EntityType,
        new FirestoreService(collection)
      );
    }
  }

  /**
   * Create entity-specific indexes
   */
  private async createEntityIndexes(): Promise<void> {
    console.log('Creating entity-specific indexes...');
    
    // Create indexes for world-scoped entities
    const worldScopedTypes = [
      EntityType.CHARACTER,
      EntityType.LOCATION,
      EntityType.ITEM,
      EntityType.EVENT,
      EntityType.FACTION
    ];

    await this.indexService.createIndex(
      'world-entities',
      worldScopedTypes,
      {
        description: 'Index for world-scoped RPG entities'
      }
    );

    // Create indexes for campaign-scoped entities
    const campaignScopedTypes = [
      EntityType.SESSION,
      EntityType.STORY_ARC
    ];

    await this.indexService.createIndex(
      'campaign-entities',
      campaignScopedTypes,
      {
        description: 'Index for campaign-scoped RPG entities'
      }
    );

    // Create indexes for global entities
    const globalTypes = [
      EntityType.NOTE,
      EntityType.CAMPAIGN,
      EntityType.RPG_WORLD
    ];

    await this.indexService.createIndex(
      'global-entities',
      globalTypes,
      {
        description: 'Index for global RPG entities'
      }
    );
  }

  /**
   * Extract searchable content from entity
   */
  private extractEntityContent(entity: any, entityType: EntityType): EntityContent {
    const baseContent = {
      title: entity.name || entity.title || 'Untitled',
      description: entity.description || '',
      tags: entity.tags || [],
      metadata: {}
    };

    // Add entity-specific content extraction
    switch (entityType) {
      case EntityType.CHARACTER:
        return {
          ...baseContent,
          description: `${baseContent.description} ${entity.race || ''} ${entity.class || ''} ${entity.background || ''}`.trim(),
          tags: [...baseContent.tags, entity.race, entity.class, entity.characterType].filter(Boolean),
          metadata: {
            race: entity.race,
            class: entity.class,
            level: entity.level,
            characterType: entity.characterType
          }
        };

      case EntityType.LOCATION:
        return {
          ...baseContent,
          tags: [...baseContent.tags, entity.locationType, entity.climate].filter(Boolean),
          metadata: {
            locationType: entity.locationType,
            climate: entity.climate,
            population: entity.population
          }
        };

      case EntityType.ITEM:
        return {
          ...baseContent,
          description: `${baseContent.description} ${entity.properties || ''}`.trim(),
          tags: [...baseContent.tags, entity.itemType, entity.rarity].filter(Boolean),
          metadata: {
            itemType: entity.itemType,
            rarity: entity.rarity,
            value: entity.value,
            weight: entity.weight
          }
        };

      case EntityType.EVENT:
        return {
          ...baseContent,
          tags: [...baseContent.tags, entity.eventType].filter(Boolean),
          metadata: {
            eventType: entity.eventType,
            importance: entity.importance,
            eventDate: entity.eventDate
          }
        };

      default:
        return baseContent;
    }
  }

  /**
   * Utility: Chunk array into smaller arrays
   */
  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }

  /**
   * Utility: Process promises with concurrency limit
   */
  private async processConcurrently<T>(
    promises: Promise<T>[],
    maxConcurrency: number
  ): Promise<T[]> {
    const results: T[] = [];
    
    for (let i = 0; i < promises.length; i += maxConcurrency) {
      const batch = promises.slice(i, i + maxConcurrency);
      const batchResults = await Promise.all(batch);
      results.push(...batchResults);
    }
    
    return results;
  }
}
